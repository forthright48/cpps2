const kue = require('kue');
const queue = kue.createQueue({
  redis: 'redis://redisdb:6379',
});
const path = require('path');
const rootPath = require('world').rootPath;
const _ = require('lodash');
const ojnames = require(path.join(rootPath, 'models/ojnames'));
const ojnamesOnly = ojnames.data.map((x)=>x.name);
const ojscraper = require('ojscraper');
const logger = require('logger');

// Mongoose
require(path.join(rootPath, './configuration/database.js'));
require(path.join(rootPath, './models/userModel.js'));
require(path.join(rootPath, './models/gateModel.js'));
const User = require('mongoose').model('User');
const Gate = require('mongoose').model('Gate');

queue.process('syncSolveCount', async function(job, done) {
  const username = job.data.title;
  try {
    const user = await User.findOne({username});
    // Grab vjudge if available
    const vjudgeStat = _.filter(user.ojStats, function(x) {
      return x.ojname === 'vjudge';
    })[0];

    if (!user) {
      logger.error(`Worker Error: Invalid username "${username}"`);
      return done(new Error(`Worker Error: Invalid username "${username}"`));
    }

    const credential = require('world').secretModule.ojscraper.loj.credential;

    // Handle missing ojs'
    const userHasOj = user.ojStats.map((x)=>x.ojname);
    const missingOjs = _.difference(ojnamesOnly, userHasOj);
    missingOjs.forEach((oj)=>{
      user.ojStats.push({
        ojname: oj,
        solveList: [],
        userIds: [],
      });
    });

    const totalOJ = user.ojStats.length;
    let doneOJ = 0;
    await Promise.all(user.ojStats.map(async function(ojStat) {
      const ojUserId = ojStat.userIds[0];
      const ojname = ojStat.ojname;
      if (ojname === 'vjudge') return 0;

      try {
        const scrap = {
          solveList: [],
        };

        if (ojUserId) {
          const ojscrap = await ojscraper.getUserInfo({
            ojname, username: ojUserId, credential,
          });
          scrap.solveList = ojscrap.solveList;
        }
        let vjudgeUserId;
        let vjudgeScrap = {
          solveList: [],
        };
        if (vjudgeStat && vjudgeStat.userIds[0]) {
          vjudgeUserId = vjudgeStat.userIds[0];
          vjudgeScrap = await ojscraper.getUserInfo({
            ojname: 'vjudge', username: vjudgeUserId, subojname: ojname,
          });
        }

        // If both ojid and vjudgeid is undefined, then solve is 0
        if (!ojUserId && ( !vjudgeStat || vjudgeStat && !vjudgeStat.userIds[0])) {
          ojStat.solveCount = 0;
          ojStat.solveList = [];
          doneOJ = doneOJ + 1; job.progress(doneOJ, totalOJ);
          return 0;
        }

        const totalSolveList = _.union(scrap.solveList, vjudgeScrap.solveList);
        const totalScrapSolveCount = totalSolveList.length;

        if ( ojStat.solveCount && ojStat.solveCount >= totalScrapSolveCount ) {
          doneOJ = doneOJ + 1; job.progress(doneOJ, totalOJ);
          return 0;
        }
        ojStat.solveCount = totalScrapSolveCount;
        const newSolved = _.difference(totalSolveList, ojStat.solveList);
        ojStat.solveList = _.orderBy(totalSolveList);

        // Synchronize newly solved problems
        await Gate.update({
          platform: ojname,
          pid: {
            $in: newSolved,
          },
        }, {
          $addToSet: {
            doneList: username,
          },
        }, {
          multi: true,
        });
        doneOJ = doneOJ + 1; job.progress(doneOJ, totalOJ);
        return 0;
      } catch (err) {
        doneOJ = doneOJ + 1; job.progress(doneOJ, totalOJ);
        logger.error(`Worker error in ${ojname}:${ojUserId} for ${username}`);
      }
    }));

    await user.save();
    return done();
  } catch (err) {
    return done(err);
  }
});
